<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ghostty Blue Flame</title>
    <style>
        :root {
            --mx: 50%;
            --my: 50%;
            --core-color: #e0f7ff; 
            --glow-color: #4d4dff; 
            --bg-color: #020205;   
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: 'Courier New', Courier, monospace;
            -webkit-font-smoothing: antialiased;
        }

        #info {
            position: absolute;
            bottom: 20px;
            color: #668;
            font-size: 14px;
            pointer-events: none;
            opacity: 0.8;
            text-align: center;
            width: 100%;
            text-shadow: 0 0 5px var(--glow-color);
            z-index: 10;
        }

        #terminal {
            display: flex;
            flex-direction: column;
            width: 100%;
            height: 100%;
            justify-content: center;
            
            color: var(--core-color);
            text-shadow: 0 0 5px var(--glow-color), 0 0 15px var(--glow-color);
            
            user-select: none;
            cursor: crosshair;
            
            background: radial-gradient(
                circle 900px at var(--mx) var(--my), 
                #111122 0%, 
                #000000 60%
            );
        }

        .row {
            white-space: pre; 
            text-align: center;
            line-height: 1.0; 
            width: 100%;
            font-weight: 900; 
            letter-spacing: 0px; 
            font-size: inherit;
        }

    </style>
    <link rel="icon" href="flame-3d.ico" type="image/x-icon">
</head>
<body>

    <div id="info">Tiny Torch • Floating Sparks • Drag to Draw Fire</div>
    
    <div id="terminal"></div>

    <script>
        const terminal = document.getElementById('terminal');

        const config = {
            fontSize: 14,
            chars: " ·+x*#%&8@$MW", 
            speed: 0.003,
            scale: 0.15,  
            rows: 0, 
            cols: 0
        };

        let time = 0;
        let mouse = { x: 0, y: 0 };
        let targetMouse = { x: 0, y: 0 };
        let rowElements = [];
        
        // Interaction State
        let isDragging = false;
        
        // Spark System State
        let sparks = [];

        function initGrid() {
            terminal.innerHTML = '';
            rowElements = [];

            const width = window.innerWidth;
            const height = window.innerHeight;

            const charWidth = config.fontSize * 0.6; 
            const charHeight = config.fontSize * 1.0;

            config.cols = Math.floor(width / charWidth);
            config.rows = Math.floor(height / charHeight);
            
            if (config.cols > 160) config.cols = 160;
            if (config.rows > 80) config.rows = 80;

            terminal.style.fontSize = `${config.fontSize}px`;

            for (let y = 0; y < config.rows; y++) {
                const div = document.createElement('div');
                div.className = 'row';
                div.textContent = ' '.repeat(config.cols); 
                terminal.appendChild(div);
                rowElements.push(div);
            }
        }

        window.addEventListener('resize', () => {
            clearTimeout(window.resizeTimer);
            window.resizeTimer = setTimeout(initGrid, 200);
        });

        // ---------------------------------------------------------
        // INTERACTION HANDLERS
        // ---------------------------------------------------------

        // Helper to convert screen pixels to simulation coordinates
        function getSimCoords(clientX, clientY) {
            // Approx grid coordinates
            let gx = clientX / (config.fontSize * 0.6);
            let gy = clientY / (config.fontSize * 1.0);
            
            // Normalize to center (matches getFlameDist logic)
            // Center is 0,0. Scale is based on rows.
            let nx = (gx - config.cols / 2) / (config.rows * 0.5);
            let ny = (gy - config.rows / 2) / (config.rows * 0.5);
            
            return { x: nx, y: ny };
        }

        function spawnDragParticles(clientX, clientY) {
             const sim = getSimCoords(clientX, clientY);
             
             // Spawn a cluster for a "thick" feel
             for(let i=0; i<3; i++) {
                sparks.push({
                    x: sim.x + (Math.random() - 0.5) * 0.05,
                    y: sim.y + (Math.random() - 0.5) * 0.05,
                    vx: (Math.random() - 0.5) * 0.01,
                    vy: -0.01 - (Math.random() * 0.02), // Upward momentum
                    life: 1.0 + Math.random() * 0.5,
                    type: 'drag' // Special type for drawn fire
                });
             }
        }

        window.addEventListener('mousedown', () => isDragging = true);
        window.addEventListener('mouseup', () => isDragging = false);
        window.addEventListener('touchstart', () => isDragging = true);
        window.addEventListener('touchend', () => isDragging = false);

        window.addEventListener('mousemove', e => {
            // Update physics target
            targetMouse.x = (e.clientX - window.innerWidth/2) / window.innerWidth;
            targetMouse.y = (e.clientY - window.innerHeight/2) / window.innerHeight;
            
            terminal.style.setProperty('--mx', `${e.clientX}px`);
            terminal.style.setProperty('--my', `${e.clientY}px`);

            if (isDragging) {
                spawnDragParticles(e.clientX, e.clientY);
            }
        });
        
        window.addEventListener('touchmove', e => {
            const touch = e.touches[0];
            targetMouse.x = (touch.clientX - window.innerWidth/2) / window.innerWidth;
            targetMouse.y = (touch.clientY - window.innerHeight/2) / window.innerHeight;
            
            terminal.style.setProperty('--mx', `${touch.clientX}px`);
            terminal.style.setProperty('--my', `${touch.clientY}px`);

            if (isDragging) {
                spawnDragParticles(touch.clientX, touch.clientY);
            }
        });

        initGrid();

        // ---------------------------------------------------------
        // MATH HELPERS
        // ---------------------------------------------------------

        function noise(x, y, t) {
            let v = 0;
            v += Math.sin(x * 8 + t);
            v += Math.sin((y * 4 + t * 2.5));
            v += Math.sin((x * 12 + y * 6 + t) / 2.0);
            return v / 1.5; 
        }

        function getFlameDist(x, y, t) {
            let nx = (x - config.cols / 2) / (config.rows * 0.5); 
            let ny = (y - config.rows / 2) / (config.rows * 0.5);

            let heightFactor = (0.6 - ny);
            if (heightFactor < 0) heightFactor = 0;
            
            // Lean Physics
            let lean = mouse.x * 0.8 * Math.pow(heightFactor, 2);
            nx -= lean;

            let wiggle = Math.sin(ny * 8 - t * 12) * 0.05 * heightFactor;
            wiggle += Math.sin(ny * 20 - t * 30) * 0.02 * heightFactor;
            
            nx += wiggle;

            let py = ny + 0.3;
            let width = 0;
            
            if (py < 0.8 && py > -1.0) {
                 width = (0.8 - py) * 0.35;
                 width += Math.cos(py * 2.5) * 0.15;
            }

            let d = Math.abs(nx) - width;

            if (py > 0.6) {
                 let dy = py - 0.6;
                 let dCap = Math.sqrt(nx*nx + dy*dy) - 0.1; 
                 d = Math.max(d, dCap - 0.1); 
            }

            return d;
        }

        // ---------------------------------------------------------
        // SPARK LOGIC
        // ---------------------------------------------------------

        function updateSparks() {
            // 1. Spawn Small sparks (Frequent) - Background ambiance
            if (Math.random() < 0.15) { 
                sparks.push({
                    x: (Math.random() - 0.5) * 0.15 + (mouse.x * 0.4), 
                    y: -0.2 + (Math.random() * 0.3),
                    vx: (Math.random() - 0.5) * 0.015,
                    vy: -0.01 - (Math.random() * 0.015),
                    life: 1.0, 
                    type: 'small'
                });
            }

            // 2. Spawn BIG Sparks (Rare)
            if (Math.random() < 0.02) { 
                sparks.push({
                    x: (Math.random() - 0.5) * 0.05 + (mouse.x * 0.4), 
                    y: -0.1, 
                    vx: (Math.random() - 0.5) * 0.005, 
                    vy: -0.005 - (Math.random() * 0.01), 
                    life: 2.0, 
                    type: 'big'
                });
            }

            // 3. Update existing
            for (let i = sparks.length - 1; i >= 0; i--) {
                let s = sparks[i];
                s.x += s.vx;
                s.y += s.vy;
                
                // Fade Rates
                let fadeRate = 0.015;
                if (s.type === 'big') fadeRate = 0.008;
                if (s.type === 'drag') fadeRate = 0.025; // User fire fades reasonably fast
                
                s.life -= fadeRate;

                // Wind effect on natural sparks
                if (s.type !== 'drag') {
                    s.x -= (mouse.x * 0.005); 
                } else {
                    // Slight turbulence for user fire
                    s.x += Math.sin(time * 20 + i) * 0.003;
                }

                if (s.life <= 0) {
                    sparks.splice(i, 1);
                }
            }
        }

        // ---------------------------------------------------------
        // RENDER LOOP
        // ---------------------------------------------------------
        function update() {
            time += config.speed;
            
            // Physics Smoothing
            mouse.x += (targetMouse.x - mouse.x) * 0.08;
            mouse.y += (targetMouse.y - mouse.y) * 0.08;

            updateSparks();

            // Map spark positions to grid characters
            let sparkSet = new Map();
            sparks.forEach(s => {
                let gx = Math.floor(s.x * (config.rows * 0.5) + config.cols / 2);
                let gy = Math.floor(s.y * (config.rows * 0.5) + config.rows / 2);
                
                if (gx >= 0 && gx < config.cols && gy >= 0 && gy < config.rows) {
                    let char = '.';
                    
                    if (s.type === 'big' || s.type === 'drag') {
                        // Heavy fire logic
                        if (s.life > 1.4) char = 'M'; // Very bright/thick
                        else if (s.life > 1.0) char = 'W';
                        else if (s.life > 0.7) char = '%';
                        else if (s.life > 0.4) char = '*';
                        else char = '·';
                    } else {
                        // Small spark
                        char = s.life > 0.5 ? "*" : "·";
                    }
                    
                    // Logic to handle overlaps: favor heavier char
                    // If a char already exists at this spot, only overwrite if new one is 'heavier'
                    // Simple heuristic: if we have a char, maybe ignore? 
                    // Or prioritize 'drag' over 'small'.
                    if (!sparkSet.has(`${gx},${gy}`) || s.type === 'drag') {
                         sparkSet.set(`${gx},${gy}`, char);
                    }
                }
            });

            for (let y = 0; y < config.rows; y++) {
                
                let lineBuffer = "";
                let noiseY = y * config.scale + time * 5; 

                for (let x = 0; x < config.cols; x++) {
                    
                    // Render Sparks/Drag Fire
                    if (sparkSet.has(`${x},${y}`)) {
                        lineBuffer += sparkSet.get(`${x},${y}`);
                        continue; 
                    }

                    let dist = getFlameDist(x, y, time);
                    
                    if (dist < 0.1) { 
                        let nVal = noise(x * config.scale, noiseY, time);
                        let coreIntensity = Math.abs(dist) * 4.0; 
                        let finalIntensity = (coreIntensity + (nVal * 0.5));
                        finalIntensity = Math.pow(finalIntensity, 1.5);
                        
                        if (finalIntensity < 0) finalIntensity = 0;
                        if (finalIntensity > 1) finalIntensity = 1;

                        let charIndex = Math.floor(finalIntensity * (config.chars.length - 1));
                        let char = config.chars[charIndex];
                        if (!char) char = config.chars[0];

                        lineBuffer += char;
                    } else {
                        lineBuffer += " ";
                    }
                }

                if (rowElements[y].textContent !== lineBuffer) {
                    rowElements[y].textContent = lineBuffer;
                }
            }

            requestAnimationFrame(update);
        }

        update();

    </script>
</body>
</html>
